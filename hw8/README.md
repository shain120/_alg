[ai chat](https://gemini.google.com/share/54d1c91f961b)
# C(n,k) 演算法比較：查表法 (Lookup) vs 動態規劃 (Dynamic Programming)

這兩份程式碼 (`CnkRLookup.py` 與 `CnkDynamic.py`) 都是用來計算組合數 $C(n, k)$（即二項式係數），且都利用了 **帕斯卡三角形 (Pascal's Triangle)** 的性質來優化計算。

儘管數學原理相同，它們採用的演算法典範（Paradigm）卻有顯著差異：
* **(`CnkRLookup.py`)**：**Top-Down（由上而下）** 的 **記憶法 (Memoization)**。
* **(`CnkDynamic.py`)**：**Bottom-Up（由下而上）** 的 **填表法 (Tabulation)**。

---

## 一、 相同之處 (Similarities)

1.  **核心數學原理**
    兩者都基於相同的遞迴關係式（帕斯卡恆等式）：
    $$C(n, k) = C(n-1, k) + C(n-1, k-1)$$
    且邊界條件（Base Case）皆為：當 $k=0$ 或 $k=n$ 時，結果為 1。

2.  **空間換取時間 (Space-Time Tradeoff)**
    兩者都使用了 **二維陣列 (2D Array)** 來儲存計算過的數值。這樣做的目的是為了避免純遞迴造成的重複計算，將時間複雜度從指數級降低到 $O(n \cdot k)$。

3.  **最終結果**
    對於相同的輸入 $(n, k)$，兩者輸出的數值完全一樣。

---

## 二、 不同之處 (Differences)

這兩者的核心差異在於 **計算的方向** 與 **資料儲存的生命週期**。

| 特性 | 圖一：查表版 (Memoization) | 圖二：動態規劃版 (Tabulation) |
| :--- | :--- | :--- |
| **計算方向** | **Top-Down (由上而下)**<br>從目標 $C(n, k)$ 開始，若沒算過就往下遞迴呼叫，直到邊界。 | **Bottom-Up (由下而上)**<br>從 $C(0, 0)$ 開始，一層一層算出所有數值，直到填滿表格至 $C(n, k)$。 |
| **實作方式** | **遞迴 (Recursion)**<br>利用函數呼叫函數自身。 | **迭代 (Iteration)**<br>利用 `for` 迴圈 (Nested Loops)。 |
| **計算範圍** | **Lazy Evaluation (惰性求值)**<br>只有需要的節點才會計算。若遞迴路徑上用不到，該格保持 `None`。 | **Eager Evaluation (急切求值)**<br>通常會算出 $0$ 到 $n$ 之間所有的組合數，填滿整個三角形。 |
| **表格生命週期** | **全域變數 (Global)**<br>陣列 `C` 定義在函數外。**跨函數呼叫有快取效果**（算完 `C(5,2)` 再算 `C(7,3)` 會利用舊資料）。 | **區域變數 (Local)**<br>陣列 `C` 在函數內宣告。每次呼叫 `c(N, K)` 都會**重新建立並重新計算**，無法共用快取。 |
| **空間大小** | **固定大小**<br>程式碼中寫死 `range(100)`，受限於預先定義的大小。 | **動態大小**<br>根據輸入的 `N` 動態建立 `(N+1)*(N+1)` 的陣列。 |
| **風險** | **Stack Overflow**<br>若 $n$ 非常大，遞迴過深可能導致堆疊溢位。 | **無**<br>使用迴圈，不會佔用 Call Stack 空間。 |

---

## 三、 程式碼細節解析

### 1. 查表版 (`CnkRLookup.py`)
* **關鍵邏輯**：
    ```python
    if not C[n][k] is None: return C[n][k]
    ```
    這是「查表」的精髓。在進行運算前，先檢查表裡是否有值。有則直接回傳，無則進行遞迴運算並寫入表中。
* **特點**：這是一種「懶惰」的算法，它假設如果不需要知道 $C(5, 3)$，就絕對不會去算它。

### 2. 動態規劃版 (`CnkDynamic.py`)
* **關鍵邏輯**：
    ```python
    for n in range(N):
        for k in range(n):
             C[n+1][k+1] = C[n][k] + C[n][k+1]
    ```
    這是「填表」的過程。它不管最後是否只需特定某個值，它會負責依照順序（Row-major）把這張表全部填滿。
* **特點**：邏輯規律，適合 GPU 加速或向量化運算，且無遞迴開銷。

---

## 四、 總結

* 如果需要 **頻繁查詢** 不同 $(n, k)$ 的值，**圖一（查表版）** 的全域變數設計效率較高（因為算過的不會重算）。
* 如果只需要 **單次計算** 且 $n$ 很大，或者擔心遞迴深度限制，**圖二（動態規劃版）** 比較安全且穩定。